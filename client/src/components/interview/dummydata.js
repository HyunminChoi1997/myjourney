export const basic = [
  {
    id: 1,
    question: "호이스팅이 무엇인가?",
    answer:
      "호이스팅은 자바스크립트의 고유의 특징으로 함수안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위 최상단으로 끌어올리는 효과를 지니는 것이다. " +
      "이때 모든 선언(var, let, const, function, class)은 현재 스코프 최상위에 끌어올려진다. " +
      "모든 선언은 호이스팅이 되지만, var로 선언된 변수들 만이 undefined로 초기화가 되기때문에 실제 선언된 위치 전에 참조가 가능하다. (var로 선언된 함수 표현식 x)" +
      "함수선언문은 그 함수 전체가 호이스팅으로 인해 최상단에 있는 효과를 지니기때문에 어딘가에 잘 구현만 되어있다면 어디서든 호출할수있다. ",
  },
  {
    id: 2,
    question: "클로저는 무엇이고 왜 쓰는것인가?",
    answer:
      "클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. " +
      "쉽게말하면 클로저는 외부함수의 변수에 접근을 하는 내부 함수를 가르킨다. " +
      "내부 함수는 자신이 선언 됐을때의 환경을 기억하고있기때문에 환경 밖에서 호출되어도 그 환경에 접근을 할 수 있다. " +
      "클로저의 장점으로는 데이터와 기능을 한곳에 모아놓을수 있는 모듈화에 있으며, #프리픽스가 나오기 전까지는 데이터를 접근 제한하는것이 없었기때문에 클로저로 은닉화를 하였다. " +
      "모듈화와 데이터 은닉화를 할수 있기때문에 캡슐화라는 특징을 가진다. ",
  },
  {
    id: 3,
    question: "불변성이란 무엇이고 왜 리액트에서 불변성을 지켜야하는가?",
    answer:
      "원시타입 데이터들은 불변성을 가지고있다, 값을 바꾼다고 해서 그 값 자체를 바뀌는게 아닌, " +
      "재할당을 하는것 뿐이다. 참조타입들은 그 참조값은 그대로지만 할당된 값은 바꿀수있기때문에 불변성을 지니고 있지 않다. " +
      "리액트에서 불변성을 지켜야하는 이유는 리액트가 상태를 업데이트하는 원리 때문인데, 상태 비교를 할때 " +
      "얕은 비교를 하기 때문에 참조값이 같고 값만 변경됐다면 변경을 인지 못하고 리랜더링을 안할수도 사이드이펙트를 발생시킬수 있기때문이다. " +
      "불변성을 지키기 위해서는 참조 타입은 spread operator, map, filter, slice, reduce등의 메소드 들을 활용하여 " +
      "새로운 배열, 객체를 만들어서 상태를 업데이트 하여야 한다.",
  },
  {
    id: 4,
    question: "이벤트 버블링은 무엇인가요?",
    answer:
      "이벤트 버블링은 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성을 의미합니다. 하지만 모든 이벤트가 버블링 하지는 않습니다" +
      "만약 똑같은 작업을하는 이벤트를 달아줘야한다면, 일일이 달아주는것이 아닌 부모 요소에 달아주기만 한다면 모든걸 한번에 핸들링할수있다는 장점이 있습니다. " +
      "stopPropagation()과 stopImmediatePropagation()으로 방지할수있지만, 정말 이유가 명확하지 않다면 막지 않는것이 좋습니다. ",
  },
];
